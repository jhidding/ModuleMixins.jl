<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Objects, Inheritance and Modules in Julia · ModuleMixins.jl</title><meta name="title" content="Objects, Inheritance and Modules in Julia · ModuleMixins.jl"/><meta property="og:title" content="Objects, Inheritance and Modules in Julia · ModuleMixins.jl"/><meta property="twitter:title" content="Objects, Inheritance and Modules in Julia · ModuleMixins.jl"/><meta name="description" content="Documentation for ModuleMixins.jl."/><meta property="og:description" content="Documentation for ModuleMixins.jl."/><meta property="twitter:description" content="Documentation for ModuleMixins.jl."/><meta property="og:url" content="https://jhidding.github.io/ModuleMixins.jl/30-blog/"/><meta property="twitter:url" content="https://jhidding.github.io/ModuleMixins.jl/30-blog/"/><link rel="canonical" href="https://jhidding.github.io/ModuleMixins.jl/30-blog/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ModuleMixins.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">ModuleMixins</a></li><li><a class="tocitem" href="../10-introduction/">Introduction</a></li><li><a class="tocitem" href="../20-example/">Example</a></li><li class="is-active"><a class="tocitem" href>Objects, Inheritance and Modules in Julia</a><ul class="internal"><li><a class="tocitem" href="#The-JIT-compiler"><span>The JIT compiler</span></a></li><li><a class="tocitem" href="#Object-Oriented-Programming"><span>Object Oriented Programming</span></a></li><li><a class="tocitem" href="#Functions,-Methods,-Interfaces"><span>Functions, Methods, Interfaces</span></a></li><li><a class="tocitem" href="#Composition-over-Inheritance"><span>Composition over Inheritance</span></a></li><li><a class="tocitem" href="#Critique-against-OOP"><span>Critique against OOP</span></a></li><li><a class="tocitem" href="#Composing-Modules"><span>Composing Modules</span></a></li><li><a class="tocitem" href="#Diamond-dependencies"><span>Diamond dependencies</span></a></li><li><a class="tocitem" href="#Performance"><span>Performance</span></a></li><li><a class="tocitem" href="#Resources"><span>Resources</span></a></li></ul></li><li><a class="tocitem" href="../50-implementation/">Implementation</a></li><li><a class="tocitem" href="../90-contributing/">Contributing guidelines</a></li><li><a class="tocitem" href="../91-developer/">Developer documentation</a></li><li><a class="tocitem" href="../95-reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Objects, Inheritance and Modules in Julia</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Objects, Inheritance and Modules in Julia</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jhidding/ModuleMixins.jl/blob/main/docs/src/30-blog.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Objects,-Inheritance-and-Modules-in-Julia"><a class="docs-heading-anchor" href="#Objects,-Inheritance-and-Modules-in-Julia">Objects, Inheritance and Modules in Julia</a><a id="Objects,-Inheritance-and-Modules-in-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Objects,-Inheritance-and-Modules-in-Julia" title="Permalink"></a></h1><p>Julia is an amazing programming language that finds its use mainly in the hands of scientific modelers. Julia combines a welcoming syntax that doesn&#39;t scare new users with stellar performance rivaling C++ and Fortran. While Julia is easy to get into – the basics are a hybrid between Python and Matlab – there are some quirks to the language that change the way you need to think about overall program architecture: there are no objects. However, don&#39;t be discouraged: there is a reason for everything. I&#39;ll explain not only how we can work around the lack of objects, but also to embrace it! Last but not least, I present a new module to plug the final hole in the sea of abstractions that is left by the absence of objects: mixins, but more on that later.</p><h2 id="The-JIT-compiler"><a class="docs-heading-anchor" href="#The-JIT-compiler">The JIT compiler</a><a id="The-JIT-compiler-1"></a><a class="docs-heading-anchor-permalink" href="#The-JIT-compiler" title="Permalink"></a></h2><p>Julia aims to be both user-friendly and fast to execute. To achieve this, we get the wonderful mix of a dynamically typed language that is compiled to machine instructions, just-in-time (JIT). This works as follows: when a function is called we know the types of the arguments (the type signature) that are given as input, and the compiler generates optimized code for that specific type signature. When the function is called again with the same signature, the compiled version is reused from cache.</p><h3 id="Multiple-dispatch"><a class="docs-heading-anchor" href="#Multiple-dispatch">Multiple dispatch</a><a id="Multiple-dispatch-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-dispatch" title="Permalink"></a></h3><p>Since the type signature is such an integral part of the execution model, there is a nice trick we can play: multiple dispatch. We can redefine the same method for many different type signatures (similar to function overloading in C++). For instance, the addition operator has (as of Julia 1.10) 189 method implementations.</p><h3 id="Multiple-dispatch-supersedes-objects"><a class="docs-heading-anchor" href="#Multiple-dispatch-supersedes-objects">Multiple dispatch supersedes objects</a><a id="Multiple-dispatch-supersedes-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-dispatch-supersedes-objects" title="Permalink"></a></h3><p>Multiple dispatch leads us to our first comparison with object oriented languages: abstract method calls are a dispatch on just the first parameter (self or this). In this respect the level of abstraction that multiple dispatch offers is more powerful than the idea of tying method implementations to compound types (i.e. objects). However, object oriented programming is more than just objects. Let&#39;s see how Julia compares.</p><h2 id="Object-Oriented-Programming"><a class="docs-heading-anchor" href="#Object-Oriented-Programming">Object Oriented Programming</a><a id="Object-Oriented-Programming-1"></a><a class="docs-heading-anchor-permalink" href="#Object-Oriented-Programming" title="Permalink"></a></h2><p>Object Oriented Programming as we know it today is a group of abstractions guided around the principle of having some way to dynamically look-up a method implementation for some object. I know this skips over the origin and abstract concepts around objects as they were found in the Smalltalk language, but that is besides the point. OOP as we know it is mostly designed around a mostly  antiquated run-time involving pointers and vtables. What I&#39;m getting at, is that the abstractions in a language are often very much guided by the underlying run-time implementation. That means that in C++ the idea of classes makes sense. In Python we already have a very different view of an object, as everything is based around objects being hashmaps with some commonly understood interface. In Julia, having such a different run-time, multiple dispatch makes sense. Quite similar to the idea that the kind of music we make or hear depends on the setting in which it is staged (opera house without electric amplification, a living room setting, a noisy café or earbuds on a daily commute) and the available technology, more so than other cultural considerations. Meanwhile, we have entire schools of thought on how to organise code and design architectures around larger code bases. These ideas have been heavily influenced by the tools of the time: Java and C++. So, all that considered, what do we understand by Object Oriented Programming?</p><ul><li>Compartimenting program state: data hiding, modularization</li><li>Message passing between objects: similar to above, an object&#39;s behaviour can be completely understood from the way we poke sticks at it.</li><li>Abstraction over interfaces: the interface is the outer shell of an object. If the implementations are widely different but the interface is the same, we can freely interchange objects of different types in cases of heterogeneous data.</li><li>Inheritance or composition: we can use smaller objects to build larger ones. This can be done by inheritance, whereby the larger object behaves the same as the smaller one, except it can do more. The other way is by composition: we wrap the smaller object into the larger one, defining a new interface, but retaining the functionality.</li></ul><p>In Julia we can achieve all these goals with multiple dispatch, except inheritance. Keep in mind that Julia is a dynamically typed language. Not only that, it fully embraces being dynamically typed through the dispatch mechanism.</p><h2 id="Functions,-Methods,-Interfaces"><a class="docs-heading-anchor" href="#Functions,-Methods,-Interfaces">Functions, Methods, Interfaces</a><a id="Functions,-Methods,-Interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Functions,-Methods,-Interfaces" title="Permalink"></a></h2><p>Ok, now we know: Julia doesn&#39;t have classes. How do we then organize our code? What are the means of abstraction? A common pattern is to define methods around types with similar utility. Suppose we want to write our own collection type, say a circular buffer that overwrites itself, only remembering the last <span>$n$</span> items that were added.</p><pre><code class="language-julia hljs">mutable struct CircularBuffer{T}
    content::Vector{T}
    endloc::Int
    length::Int
end

CircularBuffer{T}(size::Int) where T =
    CircularBuffer{T}(Vector{T}(undef, size), 1, 0)</code></pre><p>If we want <code>CircularBuffer</code> to behave like other collections in Julia, we need to define some methods.</p><pre><code class="language-julia hljs">Base.isempty(b::CircularBuffer{T}) where T = b.length == 0

function Base.empty!(b::CircularBuffer{T}) where T
    b.length = 0
    b.endloc = 1
end

Base.length(b::CircularBuffer{T}) where T = b.length
Base.checked_length(b::CircularBuffer{T}) where T = b.length</code></pre><p>Here we see that we can make methods that are in the standard library operate on our own custom types.</p><p>The weakness in this approach is that none of this is checked at compile time.</p><h2 id="Composition-over-Inheritance"><a class="docs-heading-anchor" href="#Composition-over-Inheritance">Composition over Inheritance</a><a id="Composition-over-Inheritance-1"></a><a class="docs-heading-anchor-permalink" href="#Composition-over-Inheritance" title="Permalink"></a></h2><p>Suppose we&#39;re developing something of a graphics library. We have defined a type to work with points:</p><pre><code class="language-julia hljs">struct Point
    x::Float64
    y::Float64
end

Base.:+(a::Point, b::Point) = Point(a.x+b.x, a.y+b.y)</code></pre><p>Now, we want to add colour to our points. We have a colour type that stores colour as an RGB triple. For convenience, we&#39;ll even throw in an abstract type <code>AbstractColour</code></p><pre><code class="language-julia hljs">struct Colour
    r::Float64
    g::Float64
    b::Float64
end</code></pre><p>We could do the following:</p><pre><code class="language-julia hljs">struct ColouredPoint
    x::Float64
    y::Float64
    colour::Colour
end</code></pre><p>For the <code>Point</code> type we had defined an addition operator. How would you define that for the <code>ColouredPoint</code>? How do we handle the colour information?</p><p>In this example it is quite obvious that the better other option is to use <strong>composition</strong>.</p><pre><code class="language-julia hljs">struct ColouredPoint
    point::Point
    colour::Colour
end</code></pre><p>In general, for most cases it is considered best practice to prefer composition over inheritance. Good for us, since Julia does not implement inheritance.</p><h2 id="Critique-against-OOP"><a class="docs-heading-anchor" href="#Critique-against-OOP">Critique against OOP</a><a id="Critique-against-OOP-1"></a><a class="docs-heading-anchor-permalink" href="#Critique-against-OOP" title="Permalink"></a></h2><h2 id="Composing-Modules"><a class="docs-heading-anchor" href="#Composing-Modules">Composing Modules</a><a id="Composing-Modules-1"></a><a class="docs-heading-anchor-permalink" href="#Composing-Modules" title="Permalink"></a></h2><p>Now I present another example which requires a different form of inheritance, and is not so easily expressed using object composition (of the kind shown above). Moreover, we&#39;ll see that we can combine the idea of an <strong>interface</strong> in Julia with that of a <strong>module</strong>, creating something that works much the same as a class in other languages.</p><p>We need to get an overview of the problem: we&#39;ll implement a simple physics model, first without any abstraction. Then we&#39;ll use modules and mixins to restructure that code. Along the way you&#39;ll learn an interesting fact about physical modelling. We will model a bouncing weight on a spring. The spring exerts a force proportional to the position of the weight.</p><p><img src="../fig/spring-sketch.svg" alt="Sketch of our model"/></p><p>Such a system is described by having a force proportional and opposite to the relative position of the weight. To model this system, we need to keep track of both the velocity and the position of the object.</p><p>Our model has an <code>Input</code> structure to store all the parameters, and a <code>State</code> structure that is updated on every iteration.</p><div class="mermaid">flowchart LR;
    init(&quot;initial state&quot;)
    check{&quot;t &amp;lt; t&lt;sub&gt;end&lt;/sub&gt;?&quot;}
    step![&quot;advance model&quot;]
    done(&quot;end program&quot;)

    init --&gt; step! --&gt; check
    check -- true --&gt; step!
    check -- false --&gt; done</div><p>First of all, the input structure: we need to specify the properties of the spring (spring constant, and weight of the moving object), the specifics of our time integration (in this case, the time step and final time), and the initial conditions. In a larger model there will be many more parameters.</p><pre><code class="language-julia hljs">#| id: just-a-spring
using Unitful

@kwdef struct Input
    initial_position::typeof(1.0u&quot;m&quot;)
    spring_constant::typeof(1.0u&quot;N/m&quot;)
    mass::typeof(1.0u&quot;kg&quot;)
    time_step::typeof(1.0u&quot;s&quot;)
    time_end::typeof(1.0u&quot;s&quot;)
end</code></pre><p>A typical model will have some mutable <code>State</code>.</p><pre><code class="language-julia hljs">#| id: just-a-spring
@kwdef mutable struct State
    time::typeof(1.0u&quot;s&quot;)
    position::typeof(1.0u&quot;m&quot;)
    velocity::typeof(1.0u&quot;m/s&quot;)
end</code></pre><p>The first state is created from the given input. Here, we only configure the initial position of the spring and hard-coded the initial velocity to zero.</p><pre><code class="language-julia hljs">#| id: just-a-spring
init(input::Input) =
    State(time = 0.0u&quot;s&quot;, position = input.initial_position, velocity = 0.0u&quot;m/s&quot;)</code></pre><p>Then we <code>step!</code> over this state, until some condition is met.</p><pre><code class="language-julia hljs">#| id: just-a-spring
function step!(input::Input, state::State)
    Δt = input.time_step
    Δx = state.velocity * Δt
    Δv = -state.position * input.spring_constant / input.mass * Δt

    state.time += Δt
    state.position += Δx
    state.velocity += Δv
end</code></pre><p>We&#39;ll go ahead and write the main loop in a generic way.</p><h3 id="Modules-as-classes"><a class="docs-heading-anchor" href="#Modules-as-classes">Modules as classes</a><a id="Modules-as-classes-1"></a><a class="docs-heading-anchor-permalink" href="#Modules-as-classes" title="Permalink"></a></h3><p>In Julia, modules can be passed around much the same as integers or functions <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. Given that we expect a module to have an <code>init</code> and <code>step!</code> function as well as a <code>State</code> type, we can write a generic function for running our model.</p><p>We put the previous code inside a module called <code>Spring</code> and then write a <code>run</code> function that turns a module and input record into a sequence of output values.</p><pre><code class="language-julia hljs">#| id: spring-run-slow
function run(model::Module, input)
    state = model.init(input)
    Channel{model.State}() do ch
        while state.time &lt; input.time_end
            model.step!(input, state)
            put!(ch, deepcopy(state))
        end
    end
end</code></pre><p>There is a problem with this code: it is very slow. The <code>model.init</code> and <code>model.step!</code> items are resolved through dynamic look-up. We can make it a lot faster by forcing the compiler to specialize for every model we give it.</p><pre><code class="language-julia hljs">#| id: spring-run-fast
struct Model{T} end

function run(::Type{Model{M}}, input) where M
    state = M.init(input)
    Channel{M.State}() do ch
        while state.time &lt; input.time_end
            M.step!(input, state)
            put!(ch, deepcopy(state))
        end
    end
end</code></pre><p>Let&#39;s see what this does, by visualizing the output. Here, we also show the energy of the system.</p><pre><code class="language-julia hljs">#| id: just-a-spring
function energy(input::Input, state::State)
    k = state.velocity^2 * input.mass / 2
    v = state.position^2 * input.spring_constant / 2
    return k + v
end</code></pre><details class="admonition is-details"><summary class="admonition-header">Plotting code</summary><div class="admonition-body"><pre><code class="language-julia hljs">#| id: spring-plot
function plot_result(input, output, energy)
    times = [f.time for f in output]
    pos = [f.position for f in output]

    fig = Figure()
    ax1 = Axis(fig[1:2, 1];
        ylabel = &quot;position&quot;,
        dim1_conversion = Makie.UnitfulConversion(u&quot;s&quot;),
        dim2_conversion = Makie.UnitfulConversion(u&quot;m&quot;),
    )
    lines!(ax1, times, pos)
    ax2 = Axis(fig[3, 1];
        ylabel = &quot;energy&quot;,
        dim1_conversion = Makie.UnitfulConversion(u&quot;s&quot;),
        dim2_conversion = Makie.UnitfulConversion(u&quot;J&quot;),
    )
    lines!(ax2, times, energy)
    fig
end</code></pre><pre><code class="language-julia hljs">#| file: examples/just_a_spring.jl
#| classes: [&quot;task&quot;]
#| creates:
#|   - docs/src/fig/just-a-spring.svg
#| collect: figures
module Spring
    &lt;&lt;just-a-spring&gt;&gt;
end

module Script
    using Unitful
    using CairoMakie
    using ..Spring

    &lt;&lt;spring-run-fast&gt;&gt;
    &lt;&lt;spring-plot&gt;&gt;

    function main()
        input = Spring.Input(
            time_step = 0.01u&quot;s&quot;,
            time_end = 5.0u&quot;s&quot;,
            spring_constant = 50.0u&quot;N/m&quot;,
            initial_position = 1.0u&quot;m&quot;,
            mass = 1.0u&quot;kg&quot;,
        )

        output = run(Model{Spring}, input) |&gt; collect
        energy = [Spring.energy(input, s) for s in output]
        fig = plot_result(input, output, energy)
        save(&quot;docs/src/fig/just-a-spring.svg&quot;, fig)
    end
end

Script.main()</code></pre></div></details><div class="admonition is-info"><header class="admonition-header">Simulation of a spring</header><div class="admonition-body"><p><img src="../fig/just-a-spring.svg" alt="Output of our spring simulation"/></p><p>Our simulation is running, but there appears to be something wrong here! Why is the amplitude of the oscillation increasing? Remember, we set the initial velocity to 0. After one step of forward Euler integration we have a velocity <span>$|v| &gt; 0$</span>, but the position is still the same, so the system gets a boost. The integration method is not energy conserving.</p></div></div><p>Now that we&#39;re familiar with the problem, let&#39;s try to deconstruct this program into multiple components.</p><h3 id="With-Mixins"><a class="docs-heading-anchor" href="#With-Mixins">With Mixins</a><a id="With-Mixins-1"></a><a class="docs-heading-anchor-permalink" href="#With-Mixins" title="Permalink"></a></h3><p>Now, we implement the same model using <code>ModuleMixins.jl</code>.</p><p>We define some common types:</p><pre><code class="language-julia hljs">#| id: mixin-a-spring
module Common
    export AbstractInput, AbstractState, Model, run

    abstract type AbstractInput end
    abstract type AbstractState end

    &lt;&lt;spring-run-fast&gt;&gt;
end</code></pre><p>We split our concerns into a <code>Time</code> module and a <code>Spring</code> module. Both these modules define an <code>Input</code> and <code>State</code> struct as well as the <code>init</code> and <code>step!</code> functions.</p><pre><code class="language-julia hljs">#| id: mixin-a-spring
@compose module Time
    using Unitful
    using ..Common

    @kwdef struct Input &lt;: AbstractInput
        time_step::typeof(1.0u&quot;s&quot;)
        time_end::typeof(1.0u&quot;s&quot;)
    end

    @kwdef mutable struct State &lt;: AbstractState
        time::typeof(1.0u&quot;s&quot;)
    end

    function init(input::AbstractInput)
        State(time = 0.0u&quot;s&quot;)
    end

    function step!(input::AbstractInput, state::AbstractState; fraction::Float64 = 1.0)
        state.time += fraction * input.time_step
    end
end</code></pre><p>Although the <code>Time</code> model doesn&#39;t compute anything interesting, we could call <code>Model.run(Time, Time.Input(0.1u&quot;s&quot;, 1.0u&quot;s&quot;))</code>, and collect a series of time coordinates. There is something satisfying about being able to build out complexity from humble beginnings. In the <code>Spring</code> module, we extend the <code>Input</code> and <code>State</code> definitions present in <code>Time</code> and recreate the oscillator model we had before.</p><pre><code class="language-julia hljs">#| id: mixin-a-spring
@compose module Spring
    @mixin Time
    using Unitful
    using ..Common

    @kwdef struct Input &lt;: AbstractInput
        initial_position::typeof(1.0u&quot;m&quot;)
        spring_constant::typeof(1.0u&quot;N/m&quot;)
        mass::typeof(1.0u&quot;kg&quot;)
    end

    @kwdef mutable struct State &lt;: AbstractState
        position::typeof(1.0u&quot;m&quot;)
        velocity::typeof(1.0u&quot;m/s&quot;)
    end

    accelleration(input::AbstractInput, state::AbstractState) =
        -state.position * input.spring_constant / input.mass

    energy(input::AbstractInput, state::AbstractState) =
        let k = state.velocity^2 * input.mass / 2,
            v = state.position^2 * input.spring_constant / 2
            k + v
        end

    step!(input::AbstractInput, state::AbstractState) =
        let a = accelleration(input, state)
            state.position += state.velocity * input.time_step
            state.velocity += a * input.time_step
            Time.step!(input, state)
        end

    init(input::AbstractInput) =
        State(time = 0.0u&quot;s&quot;, position = input.initial_position, velocity = 0.0u&quot;m/s&quot;)
end</code></pre><h3 id="Using-a-better-integrator"><a class="docs-heading-anchor" href="#Using-a-better-integrator">Using a better integrator</a><a id="Using-a-better-integrator-1"></a><a class="docs-heading-anchor-permalink" href="#Using-a-better-integrator" title="Permalink"></a></h3><p>In the first part we saw that there were some shortcomings to the <code>step!</code> method, in that energy was not conserved. The integration method we used is also known as the <strong>forward Euler</strong> method. There is a better way integrate systems for which energy is conserved, known as the <strong>leap-frog</strong> method. The idea is to compute the change in velocity and the change in position at times offset by half a time step. These partial step methods are known as <code>kick!</code> (changing the velocity) and <code>drift!</code> (changing the position).</p><pre><code class="language-julia hljs">#| id: mixin-a-spring
module LeapFrog
    using ..Common
    using ..Time

    function leap_frog(::Type{Model{M}}) where M
        function (input::AbstractInput, state::AbstractState)
            M.kick!(input, state)
            Time.step!(input, state; fraction = 0.5)
            M.drift!(input, state)
            Time.step!(input, state; fraction = 0.5)
        end
    end
end</code></pre><p>Now, let&#39;s see if we can extend our previous implementation of <code>Spring</code> to work with the new integrator. Notice that we can import methods from <code>Spring</code> for reuse.</p><pre><code class="language-julia hljs">#| id: mixin-a-spring
@compose module LeapFrogSpring
    @mixin Spring
    using ..Common
    using ..Spring: energy, init, accelleration
    using ..LeapFrog

    Base.convert(::Type{State}, s::Spring.State) =
        State(time=s.time, position=s.position, velocity=s.velocity)

    kick!(input::AbstractInput, state::AbstractState) =
        state.velocity += accelleration(input, state) * input.time_step

    drift!(input::AbstractInput, state::AbstractState; fraction::Float64=1.0) =
        state.position += state.velocity * input.time_step * fraction

    const step! = LeapFrog.leap_frog(Model{LeapFrogSpring})
end</code></pre><div class="admonition is-info"><header class="admonition-header">Why the `convert` function?</header><div class="admonition-body"><p>Note that the <code>Spring.init</code> function will return a value <code>Spring.State</code>. However, the <code>Model.run</code> function expects a <code>LeapFrogSpring.State</code> instead. I may patch <code>ModuleMixins</code> to create a type alias and not define a new identical type when nothing changes. For the moment, a <code>convert</code> function fixes the situation.</p></div></div><div class="admonition is-info"><header class="admonition-header">What did we use here?</header><div class="admonition-body"><p>Also note that we didn&#39;t do anything strange here. The only thing we used from <code>ModuleMixins</code> is the composition and inheritance of <code>struct</code> definitions. The rest is just using standard Julia modules creatively. Not only did we see inheritance in action, the <code>LeapFrog</code> module could be seen as a transformer, taking one interface (having <code>kick!</code> and <code>drift!</code>), and turning it into another one (generating a <code>step!</code>).</p></div></div><div class="admonition is-info"><header class="admonition-header">Result from the Leap-frog integrator</header><div class="admonition-body"><p><img src="../fig/mixin-a-spring.svg" alt="Result from the Leap-frog integration"/></p></div></div><details class="admonition is-details"><summary class="admonition-header">Plotting code</summary><div class="admonition-body"><pre><code class="language-julia hljs">#| file: examples/mixin_a_spring.jl
#| classes: [&quot;task&quot;]
#| creates:
#|   - docs/src/fig/mixin-a-spring.svg
#| collect: figures
using ModuleMixins: @compose

&lt;&lt;mixin-a-spring&gt;&gt;

module Script
    using Unitful
    using CairoMakie
    using ModuleMixins

    using ..Time
    using ..Spring
    using ..Common
    using ..LeapFrogSpring

    &lt;&lt;spring-plot&gt;&gt;

    function main()
        input = LeapFrogSpring.Input(
            time_step = 0.01u&quot;s&quot;,
            time_end = 5.0u&quot;s&quot;,
            spring_constant = 50.0u&quot;N/m&quot;,
            initial_position = 1.0u&quot;m&quot;,
            mass = 1.0u&quot;kg&quot;,
        )

        output = Common.run(Model{LeapFrogSpring}, input) |&gt; collect
        energy = map(output) do s
            # correction for overshooting
            LeapFrogSpring.drift!(input, s; fraction=-0.5)
            LeapFrogSpring.energy(input, s)
        end
        fig = plot_result(input, output, energy)
        save(&quot;docs/src/fig/mixin-a-spring.svg&quot;, fig)
    end
end

Script.main()</code></pre><pre><code class="language-julia hljs">#| id: mixin-a-spring</code></pre></div></details><p>So far, what we did could have been achieved with different techniques, like dispatch and trait types. The real reason why we use <code>ModuleMixins</code> is to handle the composition of data (i.e. <code>struct</code> types and their fields). What we&#39;ve seen here, is that the way <code>ModuleMixins</code> solves that problem blends nicely with an almost object-oriented style of programming.</p><p>We&#39;ve seen how we can use <code>ModuleMixins</code> to compose models from smaller components. The <code>Time</code> component could be reused for a different model, and we could use what we had (a forward Euler method) and extend it (to Leap-frog method), giving us both <strong>reusability</strong> and <strong>extensibility</strong>.</p><p>Where <code>ModuleMixins</code> is absolutely needed, is when our problem grows in complexity, such that data composition is no longer trivially solved by ordinary object composition. The minimal example of such a problem occurs when we have a diamond shaped dependency tree.</p><h2 id="Diamond-dependencies"><a class="docs-heading-anchor" href="#Diamond-dependencies">Diamond dependencies</a><a id="Diamond-dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Diamond-dependencies" title="Permalink"></a></h2><p>There is a case where using a construct similar to <code>ModuleMixins</code> becomes inevitable: the diamond dependency pattern.</p><pre><code class="language-julia hljs">using ModuleMixins: @compose

@compose module A
    struct S a::Int end
end

@compose module B
    @mixin A
    struct S b::Int end
end

@compose module C
    @mixin A
    struct S c::Int end
end

@compose module D
    @mixin B, C
    struct S d::Int end
end

fieldnames(D.S)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(:a, :b, :c, :d)</code></pre><p>We may draw a dependency diagram for this example:</p><div class="mermaid">graph TD
    A(&quot;A: a&quot;)
    B(&quot;B: a b&quot;)
    C(&quot;C: a c&quot;)
    D(&quot;D: a b c d&quot;)

    A --&gt; B --&gt; D
    A --&gt; C --&gt; D</div><h3 id="What-is-special-about-the-diamond?"><a class="docs-heading-anchor" href="#What-is-special-about-the-diamond?">What is special about the diamond?</a><a id="What-is-special-about-the-diamond?-1"></a><a class="docs-heading-anchor-permalink" href="#What-is-special-about-the-diamond?" title="Permalink"></a></h3><p>If we had used composition to create these dependencies, we would have arrived at a different conclusion:</p><div class="mermaid">graph TD
    A(&quot;A: a&quot;)
    B(&quot;B: (a) b&quot;)
    C(&quot;C: (a) c&quot;)
    D(&quot;D: ((a) b) ((a) c) d&quot;)

    A --&gt; B --&gt; D
    A --&gt; C --&gt; D</div><p>We end up with <strong>two</strong> copies of <code>A</code>. We could implement this so that <code>D.b.a</code> and <code>D.c.a</code> point to the same object, but doing so increases the amount of indirection and complexity in our code needlessly.</p><h2 id="Performance"><a class="docs-heading-anchor" href="#Performance">Performance</a><a id="Performance-1"></a><a class="docs-heading-anchor-permalink" href="#Performance" title="Permalink"></a></h2><pre><code class="language-julia hljs">#| file: examples/spring-benchmark.jl
using BenchmarkTools
using ModuleMixins: @compose

&lt;&lt;mixin-a-spring&gt;&gt;

module Compute
    using ..Common: Model
    using ..LeapFrogSpring: Input, State
    using Unitful

    function plain(input::Input)
        state = State(time = 0.0u&quot;s&quot;, position = input.initial_position, velocity = 0.0u&quot;m/s&quot;)
        n_steps = input.time_end / input.time_step |&gt; Int

        for i = 1:n_steps
            a = -state.position * input.spring_constant / input.mass
            state.velocity += a * input.time_step
            state.time += 0.5*input.time_step
            state.position += state.velocity * input.time_step
            state.time += 0.5*input.time_step
        end

        return state
    end

    function fancy(::Type{Model{M}}, input::Input) where M
        state = M.init(input)
        n_steps = input.time_end / input.time_step |&gt; Int

        for i = 1:n_steps
            M.step!(input, state)
        end

        return state
    end
end

module Benchmark
    using ..LeapFrogSpring
    using Unitful
    using ..Common: Model
    using ..Compute
    using BenchmarkTools

    const input = LeapFrogSpring.Input(
        time_step = 0.01u&quot;s&quot;,
        time_end = 5.0u&quot;s&quot;,
        spring_constant = 50.0u&quot;N/m&quot;,
        initial_position = 1.0u&quot;m&quot;,
        mass = 1.0u&quot;kg&quot;,
    )

    function main()
        a = @benchmark Compute.plain(Benchmark.input)
        display(a)
        b = @benchmark Compute.fancy(Model{LeapFrogSpring}, Benchmark.input)
        display(b)
    end
end

Benchmark.main()</code></pre><h2 id="Resources"><a class="docs-heading-anchor" href="#Resources">Resources</a><a id="Resources-1"></a><a class="docs-heading-anchor-permalink" href="#Resources" title="Permalink"></a></h2><ul><li><a href="https://scientificcoder.com/fruity-composable-design-patterns-in-julia">Matthijs Cox&#39;s blog post on fruity design patterns</a></li><li><a href="https://www.juliabloggers.com/the-emergent-features-of-julialang-part-ii-traits/">Emergent Features of JuliaLang, part II: traits</a></li></ul><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>That is, passed around as arguments to functions. However, modules cannot be created dynamically.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../20-example/">« Example</a><a class="docs-footer-nextpage" href="../50-implementation/">Implementation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Wednesday 16 October 2024 07:41">Wednesday 16 October 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
