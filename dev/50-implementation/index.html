<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Implementation · ModuleMixins.jl</title><meta name="title" content="Implementation · ModuleMixins.jl"/><meta property="og:title" content="Implementation · ModuleMixins.jl"/><meta property="twitter:title" content="Implementation · ModuleMixins.jl"/><meta name="description" content="Documentation for ModuleMixins.jl."/><meta property="og:description" content="Documentation for ModuleMixins.jl."/><meta property="twitter:description" content="Documentation for ModuleMixins.jl."/><meta property="og:url" content="https://jhidding.github.io/ModuleMixins.jl/50-implementation/"/><meta property="twitter:url" content="https://jhidding.github.io/ModuleMixins.jl/50-implementation/"/><link rel="canonical" href="https://jhidding.github.io/ModuleMixins.jl/50-implementation/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ModuleMixins.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">ModuleMixins</a></li><li><a class="tocitem" href="../10-introduction/">Introduction</a></li><li><a class="tocitem" href="../20-example/">Example</a></li><li><a class="tocitem" href="../30-blog/">Objects, Inheritance and Modules in Julia</a></li><li class="is-active"><a class="tocitem" href>Implementation</a><ul class="internal"><li><a class="tocitem" href="#Prelude"><span>Prelude</span></a></li><li><a class="tocitem" href="#@spec"><span><code>@spec</code></span></a></li><li><a class="tocitem" href="#Structure-of-structs"><span>Structure of structs</span></a></li><li><a class="tocitem" href="#@compose"><span><code>@compose</code></span></a></li></ul></li><li><a class="tocitem" href="../90-contributing/">Contributing guidelines</a></li><li><a class="tocitem" href="../91-developer/">Developer documentation</a></li><li><a class="tocitem" href="../95-reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Implementation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Implementation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jhidding/ModuleMixins.jl/blob/main/docs/src/50-implementation.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h1><p>The way <code>ModuleMixins</code> is implemented, is that we start out with something relatively simple, and build out from that. This means there will be some redudant code. Macros are hard to engineer, this takes you through the entire process.</p><h2 id="Prelude"><a class="docs-heading-anchor" href="#Prelude">Prelude</a><a id="Prelude-1"></a><a class="docs-heading-anchor-permalink" href="#Prelude" title="Permalink"></a></h2><pre><code class="language-julia hljs">#| file: src/ModuleMixins.jl
module ModuleMixins

using MacroTools: @capture, postwalk, prewalk

export @compose

&lt;&lt;spec&gt;&gt;
&lt;&lt;mixin&gt;&gt;
&lt;&lt;struct-data&gt;&gt;
&lt;&lt;compose&gt;&gt;

end</code></pre><p>To facilitate testing, we need to be able to compare syntax. We use the <code>clean</code> function to remove source information from expressions.</p><pre><code class="language-julia hljs">#| file: test/runtests.jl
using Test
using ModuleMixins:
    @spec,
    @spec_mixin,
    @spec_using,
    @mixin,
    Struct,
    parse_struct,
    define_struct,
    Pass,
    @compose
using MacroTools: prewalk, rmlines

clean(expr) = prewalk(rmlines, expr)

&lt;&lt;test-toplevel&gt;&gt;

@testset &quot;ModuleMixins&quot; begin
    &lt;&lt;test&gt;&gt;
end</code></pre><h2 id="@spec"><a class="docs-heading-anchor" href="#@spec"><code>@spec</code></a><a id="@spec-1"></a><a class="docs-heading-anchor-permalink" href="#@spec" title="Permalink"></a></h2><p>The <code>@spec</code> macro creates a new module, and stores its own AST inside that module.</p><pre><code class="language-julia hljs">#| id: test-toplevel
@spec module MySpec
const msg = &quot;hello&quot;
end</code></pre><pre><code class="language-julia hljs">#| id: test
@testset &quot;@spec&quot; begin
    @test clean.(MySpec.AST) == clean.([:(const msg = &quot;hello&quot;)])
    @test MySpec.msg == &quot;hello&quot;
end</code></pre><p>The <code>@spec</code> macro is used to specify the structs of a model component.</p><pre><code class="language-julia hljs">#| id: spec
&quot;&quot;&quot;
    @spec module *name*
        *body*...
    end

Create a spec. The `@spec` macro itself doesn&#39;t perform any operations other than creating a module and storing its own AST as `const *name*.AST`.

This macro is only here for teaching purposes.
&quot;&quot;&quot;
macro spec(mod)
    @assert @capture(mod, module name_
    body__
    end)

    esc(Expr(:toplevel, :(module $name
    $(body...)
    const AST = $body
    end)))
end</code></pre><h3 id="@spec_mixin"><a class="docs-heading-anchor" href="#@spec_mixin"><code>@spec_mixin</code></a><a id="@spec_mixin-1"></a><a class="docs-heading-anchor-permalink" href="#@spec_mixin" title="Permalink"></a></h3><p>We now add the <code>@mixin</code> syntax. This still doesn&#39;t do anything, other than storing the names of parent modules.</p><pre><code class="language-julia hljs">#| id: test-toplevel
@spec_mixin module MyMixinSpecOne
@mixin A
end
@spec_mixin module MyMixinSpecMany
@mixin A, B, C
end</code></pre><pre><code class="language-julia hljs">#| id: test
@testset &quot;@spec_mixin&quot; begin
    @test MyMixinSpecOne.PARENTS == [:A]
    @test MyMixinSpecMany.PARENTS == [:A, :B, :C]
end</code></pre><p>Here&#39;s the <code>@mixin</code> macro:</p><pre><code class="language-julia hljs">#| id: mixin
macro mixin(deps)
    if @capture(deps, (multiple_deps__,))
        esc(:(const PARENTS = [$(QuoteNode.(multiple_deps)...)]))
    else
        esc(:(const PARENTS = [$(QuoteNode(deps))]))
    end
end</code></pre><p>The <code>QuoteNode</code> calls prevent the symbols from being evaluated at macro expansion time. We need to make sure that the <code>@mixin</code> syntax is also available from within the module.</p><pre><code class="language-julia hljs">#| id: spec

macro spec_mixin(mod)
    @assert @capture(mod, module name_
    body__
    end)

    esc(Expr(:toplevel, :(module $name
    import ..@mixin

    $(body...)

    const AST = $body
    end)))
end</code></pre><h3 id="@spec_using"><a class="docs-heading-anchor" href="#@spec_using"><code>@spec_using</code></a><a id="@spec_using-1"></a><a class="docs-heading-anchor-permalink" href="#@spec_using" title="Permalink"></a></h3><p>I can&#39;t think of any usecase where a <code>@mixin A</code>, doesn&#39;t also mean <code>using ..A</code>. By replacing the <code>@mixin</code> with a <code>using</code> statement, we also no longer need to import <code>@mixin</code>. In fact, that macro becomes redundant. Also, in <code>@spec_using</code> we&#39;re allowed multiple <code>@mixin</code> statements.</p><pre><code class="language-julia hljs">#| id: test-toplevel
@spec_using module SU_A
const X = :hello
export X
end

@spec_using module SU_B
@mixin SU_A
const Y = X
end

@spec_using module SU_C
const Z = :goodbye
end

@spec_using module SU_D
@mixin SU_A
@mixin SU_B, SU_C
end</code></pre><pre><code class="language-julia hljs">#| id: test
@testset &quot;@spec_using&quot; begin
    @test SU_B.Y == SU_A.X
    @test SU_B.PARENTS == [:SU_A]
    @test SU_D.PARENTS == [:SU_A, :SU_B, :SU_C]
    @test SU_D.SU_C.Z == :goodbye
end</code></pre><p>We now use the <code>postwalk</code> function (from <code>MacroTools.jl</code>) to transform expressions and collect information into searchable data structures. We make a little abstraction over the <code>postwalk</code> function, so we can compose multiple transformations in a single tree walk.</p><pre><code class="language-julia hljs">#| id: test-toplevel
struct EmptyPass &lt;: Pass
    tag::Symbol
end</code></pre><pre><code class="language-julia hljs">#| id: test
@testset &quot;pass composition&quot; begin
    a = EmptyPass(:a) + EmptyPass(:b)
    @test a.parts[1].tag == :a
    @test a.parts[2].tag == :b
end</code></pre><p>A composite pass tries all of its parts in order, returning the value of the first pass that doesn&#39;t return <code>nothing</code>.</p><pre><code class="language-julia hljs">#| id: spec

abstract type Pass end

function pass(x::Pass, expr)
    error(&quot;Can&#39;t call `pass` on abstract `Pass`.&quot;)
end

struct CompositePass &lt;: Pass
    parts::Vector{Pass}
end

Base.:+(a::CompositePass...) = CompositePass(splat(vcat)(getfield.(a, :parts)))
Base.convert(::Type{CompositePass}, a::Pass) = CompositePass([a])
Base.:+(a::Pass...) = splat(+)(convert.(CompositePass, a))

function pass(cp::CompositePass, expr)
    for p in cp.parts
        result = pass(p, expr)
        if result !== :nomatch
            return result
        end
    end
    return :nomatch
end

function walk(x::Pass, expr_list)
    function patch(expr)
        result = pass(x, expr)
        result === :nomatch ? expr : result
    end
    prewalk.(patch, expr_list)
end</code></pre><pre><code class="language-julia hljs">#| id: spec
@kwdef struct MixinPass &lt;: Pass
    items::Vector{Symbol}
end

function pass(m::MixinPass, expr)
    @capture(expr, @mixin deps_) || return :nomatch

    if @capture(deps, (multiple_deps__,))
        append!(m.items, multiple_deps)
        :(
            begin
                $([:(using ..$d) for d in multiple_deps]...)
            end
        )
    else
        push!(m.items, deps)
        :(using ..$deps)
    end
end

macro spec_using(mod)
    @assert @capture(mod, module name_ body__ end)

    parents = MixinPass([])
    clean_body = walk(parents, body)

    esc(Expr(:toplevel, :(module $name
        $(clean_body...)
        const AST = $body
        const PARENTS = [$(QuoteNode.(parents.items)...)]
    end)))
end</code></pre><h2 id="Structure-of-structs"><a class="docs-heading-anchor" href="#Structure-of-structs">Structure of structs</a><a id="Structure-of-structs-1"></a><a class="docs-heading-anchor-permalink" href="#Structure-of-structs" title="Permalink"></a></h2><p>We&#39;ll convert <code>struct</code> syntax into collectable data, then convert that back into structs again. We&#39;ll support several patterns:</p><pre><code class="language-julia hljs">#| id: test
cases = Dict(
    :(struct A x end) =&gt; Struct(false, false, :A, nothing, [:x]),
    :(mutable struct A x end) =&gt; Struct(false, true, :A, nothing, [:x]),
    :(@kwdef struct A x end) =&gt; Struct(true, false, :A, nothing, [:x]),
    :(@kwdef mutable struct A x end) =&gt; Struct(true, true, :A, nothing, [:x]),
)

for (k, v) in pairs(cases)
    @testset &quot;Struct mangling: $(join(split(string(clean(k))), &quot; &quot;))&quot; begin
        @test clean(define_struct(parse_struct(k))) == clean(k)
        @test clean(define_struct(v)) == clean(k)
    end
end</code></pre><p>Each of these can have either just a <code>Symbol</code> for a name, or a <code>A &lt;: B</code> expression. This is a bit cumbersome, but we&#39;ll have to deal with all of these cases.</p><pre><code class="language-julia hljs">#| id: test
@testset &quot;Struct mangling abstracts&quot; begin
    @test parse_struct(:(struct A &lt;: B x end)).abstract_type == :B
    @test parse_struct(:(mutable struct A &lt;: B x end)).abstract_type == :B
end</code></pre><pre><code class="language-julia hljs">#| id: struct-data

struct Struct
    use_kwdef::Bool
    is_mutable::Bool
    name::Symbol
    abstract_type::Union{Symbol,Nothing}
    fields::Vector{Union{Expr,Symbol}}
end

function extend_struct!(s1::Struct, s2::Struct)
    append!(s1.fields, s2.fields)
end

function parse_struct(expr)
    @capture(expr, (@kwdef kw_struct_expr_) | struct_expr_)
    uses_kwdef = kw_struct_expr !== nothing
    struct_expr = uses_kwdef ? kw_struct_expr : struct_expr

    @capture(struct_expr,
        (struct name_ fields__ end) |
        (mutable struct mut_name_ fields__ end)) || return

    is_mutable = mut_name !== nothing
    sname = is_mutable ? mut_name : name
    @capture(sname, (name_ &lt;: abst_) | name_)

    return Struct(uses_kwdef, is_mutable, name, abst, fields)
end

function define_struct(s::Struct)
    name = s.abstract_type !== nothing ? :($(s.name) &lt;: $(s.abstract_type)) : s.name
    sdef = if s.is_mutable
        :(mutable struct $name
            $(s.fields...)
        end)
    else
        :(struct $name
            $(s.fields...)
        end)
    end
    s.use_kwdef ? :(@kwdef $sdef) : sdef
end</code></pre><h2 id="@compose"><a class="docs-heading-anchor" href="#@compose"><code>@compose</code></a><a id="@compose-1"></a><a class="docs-heading-anchor-permalink" href="#@compose" title="Permalink"></a></h2><p>Unfortunately now comes a big leap. We&#39;ll merge all struct definitions inside the body of a module definition with that of its parents. We must also make sure that a <code>struct</code> definition still compiles, so we have to take along <code>using</code> and <code>const</code> statements.</p><pre><code class="language-julia hljs">#| id: test-toplevel
module ComposeTest1
using ModuleMixins

@compose module A
    struct S
        a::Int
    end
end

@compose module B
    struct S
        b::Int
    end
end

@compose module AB
    @mixin A, B
end
end</code></pre><pre><code class="language-julia hljs">#| id: test
@testset &quot;compose struct members&quot; begin
    @test ComposeTest1.AB.PARENTS == [:A, :B]
    @test fieldnames(ComposeTest1.AB.S) == (:a, :b)
end</code></pre><pre><code class="language-julia hljs">#| id: compose

struct CollectUsingPass &lt;: Pass
    items::Vector{Expr}
end

function pass(p::CollectUsingPass, expr)
    @capture(expr, using x__ | using mod__: x__) || return :nomatch
    push!(p.items, expr)
    return nothing
end

struct CollectConstPass &lt;: Pass
    items::Vector{Expr}
end

function pass(p::CollectConstPass, expr)
    @capture(expr, const x_ = y_) || return :nomatch
    push!(p.items, expr)
    return nothing
end

struct CollectStructPass &lt;: Pass
    items::IdDict{Symbol,Struct}
end

function pass(p::CollectStructPass, expr)
    s = parse_struct(expr)
    s === nothing &amp;&amp; return :nomatch
    if s.name in keys(p.items)
        extend_struct!(p.items[s.name], s)
    else
        p.items[s.name] = s
    end
    return nothing
end

&quot;&quot;&quot;
    @compose module Name
        [@mixin Parents, ...]
        ...
    end

Creates a new composable module `Name`. Structs inside this module are
merged with those of the same name in `Parents`.
&quot;&quot;&quot;
macro compose(mod)
    @assert @capture(mod, module name_ body__ end)

    mixins = Symbol[]
    parents = MixinPass([])
    usings = CollectUsingPass([])
    consts = CollectConstPass([])
    structs = CollectStructPass(IdDict())

    function mixin(expr)
        parents = MixinPass([])
        pass1 = walk(parents, expr)
        for p in parents.items
            p in mixins &amp;&amp; continue
            push!(mixins, p)
            parent_expr = Core.eval(__module__, :($(p).AST))
            mixin(parent_expr)
        end
        walk(usings + consts + structs, pass1)
    end

    clean_body = mixin(body)

    esc(Expr(:toplevel, :(module $name
        $(usings.items...)
        $(consts.items...)
        $(define_struct.(values(structs.items))...)
        $(clean_body...)
        const AST = $body
        const PARENTS = [$(QuoteNode.(mixins)...)]
    end)))
end</code></pre><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../30-blog/">« Objects, Inheritance and Modules in Julia</a><a class="docs-footer-nextpage" href="../90-contributing/">Contributing guidelines »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Monday 7 October 2024 14:27">Monday 7 October 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
